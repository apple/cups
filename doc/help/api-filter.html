<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!-- SECTION: Programming -->
<head>
<title>Filter and Backend Programming</title>
<meta name="keywords" content="Programming">
<meta name="creator" content="Mini-XML v2.5">
<style type="text/css"><!--
BODY {
  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
}

H1, H2, H3, H4, H5, H6, P, TD, TH {
  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
}

KBD {
  font-family: monaco, courier, monospace;
  font-weight: bold;
}

PRE {
  font-family: monaco, courier, monospace;
}

PRE.command {
  margin-left: 36pt;
}

PRE.example {
  background: #eeeeee;
  border: dotted thin #999999;
  margin-left: 36pt;
  padding: 10px;
}

PRE.command EM, PRE.example EM {
  font-family: lucida grande, geneva, helvetica, arial, sans-serif;
}

P.command {
  font-family: monaco, courier, monospace;
  margin-left: 36pt;
}

P.formula {
  font-style: italic;
  margin-left: 36pt;
}

BLOCKQUOTE {
  background: #cccccc;
  border: solid thin #999999;
  padding: 10pt;
}

A:link, A:visited {
  text-decoration: none;
  font-weight: bold;
}

A:link:hover, A:visited:hover, A:active {
  text-decoration: underline;
  font-weight: bold;
}

SUB, SUP {
  font-size: 50%;
}

DIV.table TABLE {
  border: solid thin #999999;
  border-collapse: collapse;
  border-spacing: 0;
  margin-left: auto;
  margin-right: auto;
}

DIV.table CAPTION {
  caption-side: top;
  font-size: 120%;
  font-style: italic;
  font-weight: bold;
  margin-left: auto;
  margin-right: auto;
}

DIV.table TABLE TD {
  border: solid thin #cccccc;
  padding-top: 5pt;
}

DIV.table TABLE TH {
  background: #cccccc;
  border: none;
  border-bottom: solid thin #999999;
}

DIV.figure TABLE {
  margin-left: auto;
  margin-right: auto;
}

DIV.figure CAPTION {
  caption-side: bottom;
  font-size: 120%;
  font-style: italic;
  font-weight: bold;
  margin-left: auto;
  margin-right: auto;
}

TH.label {
  padding-top: 5pt;
  text-align: right;
  vertical-align: top;
}

HR {
  border: solid thin;
}

SPAN.info {
  background: #000000;
  border: thin solid #000000;
  color: #ffffff;
  font-size: 80%;
  font-style: italic;
  font-weight: bold;
  white-space: nowrap;
}

H2 SPAN.info, H3 SPAN.info, H4 SPAN.info {
  float: right;
  font-size: 100%;
}

H2.title, H3.title {
  border-bottom: solid 2pt #000000;
}

DT {
  margin-left: 36pt;
  margin-top: 12pt;
}

DD {
  margin-left: 54pt;
}

DL.category DT {
  font-weight: bold;
}

P.summary {
  margin-left: 36pt;
  font-family: monaco, courier, monospace;
}

SPAN.message {
  font-style: italic;
  font-size: smaller;
}

DIV.summary TABLE {
  border: solid thin #999999;
  border-collapse: collapse;
  border-spacing: 0;
  margin: 10px;
}

DIV.summary TABLE TD, DIV.summary TABLE TH {
  border: solid thin #999999;
  padding: 5px;
  text-align: left;
  vertical-align: top;
}

DIV.summary TABLE THEAD TH {
  background: #eeeeee;
}

/* API documentation styles... */
div.body h1 {
  margin: 0;
}
div.body h2 {
  margin-top: 1.5em;
}
div.body h3, div.body h4, div.body h5 {
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
.class, .enumeration, .function, .struct, .typedef, .union {
  border-bottom: solid thin #999999;
  margin-bottom: 0;
  margin-top: 2em;
}
.description {
  margin-top: 0.5em;
}
code, p.code, pre, ul.code li {
  font-family: monaco, courier, monospace;
  font-size: 90%;
}
ul.code, ul.contents, ul.subcontents {
  list-style-type: none;
  margin: 0;
  padding-left: 0;
}
ul.code li {
  margin: 0;
}
ul.contents > li {
  margin-top: 1em;
}
ul.contents li ul.code, ul.contents li ul.subcontents {
  padding-left: 2em;
}
div.body dl {
  margin-left: 0;
  margin-top: 0;
}
div.body dt {
  font-style: italic;
  margin-left: 0;
  margin-top: 0;
}
div.body dd {
  margin-bottom: 0.5em;
}

/* This is just for the HTML files generated with the framedhelp target */
div.contents {
  background: #e8e8e8;
  border: solid thin black;
  padding: 10px;
}
div.contents h1 {
  font-size: 110%;
}
div.contents h2 {
  font-size: 100%;
}
div.contents ul.contents {
  font-size: 80%;
}
--></style>
</head>
<body>
<div class='body'>
<h2 class="title">Contents</h2>
<ul class="contents">
</li>
<li><a href="#FUNCTIONS">Functions</a><ul class="code">
<li><a href="#cupsBackChannelRead" title="Read data from the backchannel.">cupsBackChannelRead</a></li>
<li><a href="#cupsBackChannelWrite" title="Write data to the backchannel.">cupsBackChannelWrite</a></li>
<li><a href="#cupsSideChannelDoRequest" title="Send a side-channel command to a backend and wait for a response.">cupsSideChannelDoRequest</a></li>
<li><a href="#cupsSideChannelRead" title="Read a side-channel message.">cupsSideChannelRead</a></li>
<li><a href="#cupsSideChannelWrite" title="Write a side-channel message.">cupsSideChannelWrite</a></li>
</ul>
</ul>
<!--
  "$Id: api-filter.shtml 6649 2007-07-11 21:46:42Z mike $"

  Filter and backend API introduction for the Common UNIX Printing System (CUPS).

  Copyright 2007 by Apple Inc.
  Copyright 1997-2006 by Easy Software Products, all rights reserved.

  These coded instructions, statements, and computer programs are the
  property of Apple Inc. and are protected by Federal copyright
  law.  Distribution and use rights are outlined in the file "LICENSE.txt"
  which should have been included with this file.  If this file is
  file is missing or damaged, see the license at "http://www.cups.org/".
-->

<h2 class='title'>Introduction</h2>

<p>The CUPS filter and backend APIs define standard exit codes
and provide access to the backchannel data stream. They are only
used when writing backends, filters, and port monitors.</p>

<h2 class='title'>General Usage</h2>

<p>The <var>&lt;cups/backend.h&gt;</var> and
<var>&lt;cups/cups.h&gt;</var> header files must be included to
use the <tt>CUPS_BACKEND_</tt> constants and
<tt>cupsBackChannel</tt> functions, respectively.</p>

<p>The <var>&lt;cups/sidechannel.h&gt;</var> header file must be
included to use the <tt>CUPS_SC_</tt> constants and <tt>cupsSideChannel</tt> functions.</p>

<p>Programs using these functions must be linked to the CUPS
library: <var>libcups.a</var>, <var>libcups.so.2</var>,
<var>libcups.2.dylib</var>, <var>libcups_s.a</var>, or
<var>libcups2.lib</var> depending on the platform. The following
command compiles <var>myprogram.c</var> using GCC and the CUPS
library:</p>

<pre class='command'>
<kbd>gcc -o myprogram myprogram.c -lcups</kbd>
</pre>


<h2 class='title'>Compatibility</h2>

<p>The <tt>cupsBackChannel</tt> functions require CUPS 1.2 or higher. The <tt>cupsSideChannel</tt> functions require CUPS 1.3 or higher.</p>


<h2 class='title'>Using the cupsBackChannel APIs</h2>

<p>The <tt>cupsBackChannel</tt> APIs allow your filters, drivers, and port monitors to read data back from a printer and your backends to send data from a printer to the filters, drivers, and port monitors associated with the current job. Back-channel data is normally sent by the printer in response to a command sent from your program to the printer via <tt>stdout</tt>.</p>

<p>The <tt>cupsBackChannelRead()</tt> function reads data from the printer via the backend. You provide a timeout in seconds along with a buffer pointer and the size of that buffer. It returns the number of bytes or -1 if there was an error. The following code example shows how to poll for back-channel data in your program:</p>

<pre class='command'>
#include &lt;cups/cups.h&gt;

char buffer[8192];
ssize_t bytes;

/* Use a timeout of 0.0 seconds to poll for back-channel data */
bytes = cupsBackChannelRead(buffer, sizeof(buffer), 0.0);
</pre>

<p>If you are writing a backend, the <tt>cupsBackChannelWrite()</tt> function sends any back-channel data you have received from the printer to upstream filters in the print filter chain. We recommend using a timeout of 1.0 seconds:</p>

<pre class='command'>
#include &lt;cups/cups.h&gt;

char buffer[8192];
ssize_t bytes;

/* Use a timeout of 1.0 seconds to give filters a chance to read */
cupsBackChannelWrite(buffer, bytes, 1.0);
</pre>


<h2 class='title'>Using the cupsSideChannel APIs</h2>

<p>The <tt>cupsSideChannel</tt> APIs allow your filters, drivers, port monitors, and backend to send and receive the following out-of-band commands:</p>

<ul>

	<li><tt>CUPS_SC_CMD_SOFT_RESET</tt> -  Do a soft reset</li>
	<li><tt>CUPS_SC_CMD_DRAIN_OUTPUT</tt> -  Drain all pending output</li>
	<li><tt>CUPS_SC_CMD_GET_BIDI</tt> -  Return bidirectional capabilities</li>
	<li><tt>CUPS_SC_CMD_GET_DEVICE_ID</tt> -  Return the IEEE-1284 device ID</li>
	<li><tt>CUPS_SC_CMD_GET_STATE</tt> - Return the device state</li>

</ul>


<h3>Sending Commands from a Filter, Driver, or Port Monitor</h3>

<p>The <tt>cupsSideChannelDoRequest()</tt> function is used by filters, drivers, and port monitors to send a command to the backend and read back a response:</p>

<pre class='command'>
cups_sc_status_t cupsSideChannelDoRequest(cups_sc_command_t command,
                                          char *data, int *datalen,
                                          double timeout);
</pre>

<p>The <tt>CUPS_SC_CMD_SOFT_RESET</tt> and <tt>CUPS_SC_CMD_DRAIN_OUTPUT</tt> commands do not return any data values, while the others return one or more bytes. The <tt>timeout</tt> parameter allows your program to poll or wait for the command to complete - use a timeout of 30 seconds for <tt>CUPS_SC_CMD_SOFT_RESET</tt> and <tt>CUPS_SC_CMD_DRAIN_OUTPUT</tt> and a timeout of 1 second for all other commands.</p>

<p><tt>CUPS_SC_CMD_GET_BIDI</tt> returns a single <tt>char</tt> value that tells you whether the backend supports bidirectional communications:</p>

<pre class='command'>
#include &lt;cups/sidechannel.h&gt;

char data;
int datalen;
cups_sc_bidi_t bidi;
cups_sc_status_t status;

/* Tell cupsSideChannelDoRequest() how big our buffer is... */
datalen = 1;

/* Get the bidirectional capabilities, waiting for up to 1 second */
status  = cupsSideChannelDoRequest(CUPS_SC_CMD_GET_BIDI, &amp;data, &amp;datalen, 1.0);

/* Use the returned value if OK was returned and the length is still 1 */
if (status == CUPS_SC_STATUS_OK && datalen == 1)
  bidi = (cups_sc_bidi_t)data;
else
  bidi = CUPS_SC_BIDI_NOT_SUPPORTED;
</pre>

<p><tt>CUPS_SC_CMD_GET_DEVICE_ID</tt> returns a string of characters containing the IEEE-1284 device ID for the connected printer:</p>

<pre class='command'>
#include &lt;cups/sidechannel.h&gt;

char data[2049];
int datalen;
cups_sc_status_t status;

/* Tell cupsSideChannelDoRequest() how big our buffer is, less 1 byte for nul-termination... */
datalen = sizeof(data) - 1;

/* Get the IEEE-1284 device ID, waiting for up to 1 second */
status  = cupsSideChannelDoRequest(CUPS_SC_CMD_GET_DEVICE_ID, data, &amp;datalen, 1.0);

/* Use the returned value if OK was returned and the length is non-zero */
if (status == CUPS_SC_STATUS_OK && datalen > 0)
  data[datalen] = '\0';
else
  data[0] = '\0';
</pre>

<p><tt>CUPS_SC_CMD_GET_STATE</tt> returns a single <tt>char</tt> value that tells you the current device state:</p>

<pre class='command'>
#include &lt;cups/sidechannel.h&gt;

char data;
int datalen;
cups_sc_state_t state;
cups_sc_status_t status;

/* Tell cupsSideChannelDoRequest() how big our buffer is... */
datalen = 1;

/* Get the bidirectional capabilities, waiting for up to 1 second */
status  = cupsSideChannelDoRequest(CUPS_SC_CMD_GET_STATE, &amp;data, &amp;datalen, 1.0);

/* Use the returned value if OK was returned and the length is still 1 */
if (status == CUPS_SC_STATUS_OK && datalen == 1)
  state = (cups_sc_state_t)data;
else
  state = CUPS_SC_STATE_OFFLINE;
</pre>


<h3>Handling Commands in your Backend</h3>

<p>The <tt>cupsSideChannelRead()</tt> function is used by backends to read a command from a filter, driver, or port monitor:</p>

<pre class='command'>
int cupsSideChannelRead(cups_sc_command_t &amp;command,
                        cups_sc_status_t  &amp;status,
                        char *data, int *datalen, double timeout);
</pre>

<p>Backends can either poll for commands using a <tt>timeout</tt> of 0.0, wait indefinitely for commands using a <tt>timeout</tt> of -1.0 (probably in a separate thread for that purpose), or use <tt>select()</tt> or <tt>poll()</tt> on the <tt>CUPS_SC_FD</tt> file descriptor (4) to handle input and output on several file descriptors at the same time. Backends can pass <tt>NULL</tt> for the <tt>data</tt> and <tt>datalen</tt> parameters, since none of the commands sent by upstream filters contain any data at this time.</p>

<p>Once a command is processed, the backend uses the <tt>cupsSideChannelWrite()</tt> function to send its response:</p>

<pre class='command'>
#include &lt;cups/sidechannel.h&gt;

cups_sc_command_t command;
cups_sc_status_t status;

/* Poll for a command... */
if (!cupsSideChannelRead(&amp;command, &amp;status, NULL, NULL, 0.0))
{
  char data[2048];
  int datalen;

  switch (command)
  {
    ... handle supported commands, file data/datalen/status with values as needed ...

    default :
        status  = CUPS_SC_STATUS_NOT_IMPLEMENTED;
	datalen = 0;
	break;
  }

  /* Send a response... */
  cupsSideChannelWrite(command, status, data, datalen, 1.0);
}
</pre>
<h2 class="title"><a name="FUNCTIONS">Functions</a></h2>
<h3 class="function"><span class="info">&nbsp;CUPS 1.2&nbsp;</span><a name="cupsBackChannelRead">cupsBackChannelRead</a></h3>
<p class="description">Read data from the backchannel.</p>
<p class="code">
ssize_t cupsBackChannelRead (<br>
&nbsp;&nbsp;&nbsp;&nbsp;char *buffer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;size_t bytes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>buffer</dt>
<dd class="description">Buffer to read</dd>
<dt>bytes</dt>
<dd class="description">Bytes to read</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Bytes read or -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">Reads up to &quot;bytes&quot; bytes from the backchannel. The &quot;timeout&quot;
parameter controls how many seconds to wait for the data - use
0.0 to return immediately if there is no data, -1.0 to wait
for data indefinitely.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.2&nbsp;</span><a name="cupsBackChannelWrite">cupsBackChannelWrite</a></h3>
<p class="description">Write data to the backchannel.</p>
<p class="code">
ssize_t cupsBackChannelWrite (<br>
&nbsp;&nbsp;&nbsp;&nbsp;const char *buffer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;size_t bytes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>buffer</dt>
<dd class="description">Buffer to write</dd>
<dt>bytes</dt>
<dd class="description">Bytes to write</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Bytes written or -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">Writes &quot;bytes&quot; bytes to the backchannel. The &quot;timeout&quot; parameter
controls how many seconds to wait for the data to be written - use
0.0 to return immediately if the data cannot be written, -1.0 to wait
indefinitely.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.3&nbsp;</span><a name="cupsSideChannelDoRequest">cupsSideChannelDoRequest</a></h3>
<p class="description">Send a side-channel command to a backend and wait for a response.</p>
<p class="code">
<a href="#cups_sc_status_t">cups_sc_status_t</a> cupsSideChannelDoRequest (<br>
&nbsp;&nbsp;&nbsp;&nbsp;cups_sc_command_t command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;char *data,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int *datalen,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>command</dt>
<dd class="description">Command to send</dd>
<dt>data</dt>
<dd class="description">Response data buffer pointer</dd>
<dt>datalen</dt>
<dd class="description">Size of data buffer on entry, number of bytes in buffer on return</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Status of command</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function is normally only called by filters, drivers, or port
monitors in order to communicate with the backend used by the current
printer.  Programs must be prepared to handle timeout or &quot;not
implemented&quot; status codes, which indicate that the backend or device
do not support the specified side-channel command.<br>
<br>
The &quot;datalen&quot; parameter must be initialized to the size of the buffer
pointed to by the &quot;data&quot; parameter.  cupsSideChannelDoRequest() will
update the value to contain the number of data bytes in the buffer.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.3&nbsp;</span><a name="cupsSideChannelRead">cupsSideChannelRead</a></h3>
<p class="description">Read a side-channel message.</p>
<p class="code">
int cupsSideChannelRead (<br>
&nbsp;&nbsp;&nbsp;&nbsp;cups_sc_command_t *command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_sc_status_t">cups_sc_status_t</a> *status,<br>
&nbsp;&nbsp;&nbsp;&nbsp;char *data,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int *datalen,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>command</dt>
<dd class="description">Command code</dd>
<dt>status</dt>
<dd class="description">Status code</dd>
<dt>data</dt>
<dd class="description">Data buffer pointer</dd>
<dt>datalen</dt>
<dd class="description">Size of data buffer on entry, number of bytes in buffer on return</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function is normally only called by backend programs to read
commands from a filter, driver, or port monitor program.  The
caller must be prepared to handle incomplete or invalid messages
and return the corresponding status codes.<br>
<br>
The &quot;datalen&quot; parameter must be initialized to the size of the buffer
pointed to by the &quot;data&quot; parameter.  cupsSideChannelDoRequest() will
update the value to contain the number of data bytes in the buffer.

</p>
<h3 class="function"><span class="info">&nbsp;CUPS 1.3&nbsp;</span><a name="cupsSideChannelWrite">cupsSideChannelWrite</a></h3>
<p class="description">Write a side-channel message.</p>
<p class="code">
int cupsSideChannelWrite (<br>
&nbsp;&nbsp;&nbsp;&nbsp;cups_sc_command_t command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cups_sc_status_t">cups_sc_status_t</a> status,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const char *data,<br>
&nbsp;&nbsp;&nbsp;&nbsp;int datalen,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double timeout<br>
);</p>
<h4 class="parameters">Parameters</h4>
<dl>
<dt>command</dt>
<dd class="description">Command code</dd>
<dt>status</dt>
<dd class="description">Status code</dd>
<dt>data</dt>
<dd class="description">Data buffer pointer</dd>
<dt>datalen</dt>
<dd class="description">Number of bytes of data</dd>
<dt>timeout</dt>
<dd class="description">Timeout in seconds</dd>
</dl>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function is normally only called by backend programs to send
responses to a filter, driver, or port monitor program.

</p>
</div>
</body>
</html>
