%    Copyright (C) 1995, 1996, 1998 Aladdin Enterprises.  All rights reserved.
% 
% This file is part of GNU Ghostscript.
% 
% GNU Ghostscript is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
% to anyone for the consequences of using it or for whether it serves any
% particular purpose or works at all, unless he says so in writing.  Refer
% to the GNU General Public License for full details.
% 
% Everyone is granted permission to copy, modify and redistribute GNU
% Ghostscript, but only under the conditions described in the GNU General
% Public License.  A copy of this license is supposed to have been given
% to you along with GNU Ghostscript so you can know your rights and
% responsibilities.  It should be in a file named COPYING.  Among other
% things, the copyright notice and this notice must be preserved on all
% copies.
% 
% Aladdin Enterprises supports the work of the GNU Project, but is not
% affiliated with the Free Software Foundation or the GNU Project.  GNU
% Ghostscript, as distributed by Aladdin Enterprises, does not require any
% GNU software to build or run it.

% $Id: gs_fform.ps,v 1.2 2000/03/08 23:14:29 mike Exp $
% Form caching implemented in PostScript.

% This implementation doesn't do the right thing about halftone or
% Pattern phase, but the Pattern cache doesn't either....

% The Form cache key is the Form dictionary; the value is an array
% of 2 elements [CTM pattern_instance].
%
% In order to prevent restore from clearing the cache, we explicitly
% push the cache entries on the stack before a restore and reinstall them.
currentglobal false setglobal
/.formcachedict 20 dict def	% must be local
true setglobal
/restore {
  mark .formcachedict { } forall
  counttomark 1 add index { restore } .internalstopped
    { cleartomark restore }
    { counttomark 2 idiv { .formcachedict 3 1 roll put } repeat pop pop }
  ifelse
} bind odef

/.execform1 {
  dup /Implementation known not {
    dup /FormType get 1 ne { /rangecheck signalerror } if
		% The Implementation is a Pattern that will draw the form.
    currentglobal 1 index gcheck setglobal
		% Stack: form global
    10 dict begin
      /PatternType 1 def
      /PaintType 1 def	% colored
      /TilingType 1 def	% irrelevant
		% Copy the BBox to the correct VM.
      /BBox 2 index /BBox get 4 array copy exch 1 index def
		% Set XStep and YStep to very large numbers,
		% so we won't get multiple copies of the form.
      /XStep 1 index dup 2 get exch 0 get sub 100 mul def
      /YStep exch dup 3 get exch 1 get sub 100 mul def
      /PaintProc 2 index /PaintProc get def
    currentdict end readonly
		% Stack: form global impl
    exch setglobal
    1 index /Implementation 3 -1 roll .forceput
  } if
  .formcachedict 1 index .knownget {
		% Check whether we can use the cached value.
		% Stack: form cachevalue
    matrix currentmatrix true 0 1 3 {
		% Stack: form cachevalue curmat true index
      3 index 0 get 1 index get exch 3 index exch get ne {
	pop pop false exit
      } if
    } for exch pop
  } {
    false
  } ifelse not
  {		% Make a new cache entry.
    gsave
    matrix currentmatrix dup 4 0 put dup 5 0 put dup setmatrix
		% Stack: form mat
    1 index /Implementation get
    2 index /Matrix get
    makepattern 2 array astore
    .formcachedict 2 index 2 index put
    grestore
  } if
		% Stack: form cachevalue
  -1 0 0 transform
  2 { exch round cvi } repeat .setscreenphase
  1 get setpattern
  /BBox get aload pop
  exch 3 index sub exch 2 index sub rectfill
} .bind odef	% must bind .forceput

.formtypes 1 /.execform1 load put

setglobal
